#pragma kernel SetToOnes
#pragma kernel PackToTexture
#pragma kernel UnpackFromTexture
#pragma kernel DirectionalCopy
#pragma kernel PropagateFromAmbient
#pragma kernel PropagateFromUpperLevel
#pragma kernel UnpackFromLightingTower

/**********************************************************************************/


RWStructuredBuffer<float> RSM_gv;
RWTexture3D<float> LPV_gv;
Texture3D<float> Input_gv, UpperLevelInput_gv;
uint GridResolution;
uint3 DX, DY, DZ;
uint4 CurrentCascadeIndex, UpperCascadeIndex;
RWTexture3D<float4> LightingTower;
float4 AmbientForward, AmbientBackward;


[numthreads(64, 1, 1)]
void SetToOnes(uint3 id : SV_DispatchThreadID)
{
    RSM_gv[id.x] = 1.0;
}

[numthreads(4, 4, 4)]
void PackToTexture(uint3 id : SV_DispatchThreadID)
{
    uint src_index = (id.z * GridResolution + id.y) * GridResolution + id.x;
    LPV_gv[id] = RSM_gv[src_index];
}

[numthreads(4, 4, 4)]
void UnpackFromTexture(uint3 id : SV_DispatchThreadID)
{
    uint dst_index = (id.z * GridResolution + id.y) * GridResolution + id.x;
    RSM_gv[dst_index] = LPV_gv[id];
}

[numthreads(4, 4, 4)]
void DirectionalCopy(uint3 id : SV_DispatchThreadID)
{
    uint3 dst_id = id + (GridResolution >> 2);
    uint3 input_id = id * 2;

    float4 transparency1 = float4(
        Input_gv[input_id],
        Input_gv[input_id + DX],
        Input_gv[input_id + DY],
        Input_gv[input_id + DX + DY]);

    input_id += DZ;
    float4 transparency2 = float4(
        Input_gv[input_id],
        Input_gv[input_id + DX],
        Input_gv[input_id + DY],
        Input_gv[input_id + DX + DY]);

    LPV_gv[dst_id] = dot(transparency1, transparency2) * 0.25;
}

[numthreads(4, 4, 4)]
void PropagateFromAmbient(uint3 id : SV_DispatchThreadID)
{
    /* propagate light from the ambient lighting into the highest-level cascade,
       along the two directions DZ and -DZ */
    uint3 id2;
    float3 color = AmbientForward.rgb;
    float3 color2 = AmbientBackward.rgb;

    if (any(id < DZ))
    {
        id2 = id + DZ * (GridResolution - 1);
    }
    else
    {
        id2 = id - DZ;
        color *= Input_gv[id2];
        color2 *= Input_gv[id];
    }
    LightingTower[id + CurrentCascadeIndex.xyz] = float4(color, Input_gv[id]);
    LightingTower[id2 + CurrentCascadeIndex.wyz] = float4(color2, Input_gv[id2]);
}

float3 ApplyTransparency(float4 color)
{
    return color.rgb * color.a;
}

float3 FetchNextLightingTowerColor(int3 id, uint3 cascade_index)
{
    /* manually interpolate.  Note that even if we could use automatic interpolation,
       it wouldn't quite work with the way we store data as RGB plus transparency,
       because RGB is not alpha-premultiplied.  That's why we need to call
       ApplyTransparency() on all source pixels, not on the final mean value.
       This is needed because in the end we are interested in the RGB value on actual
       triangles, where the alpha is typically 0.

       'id' is three integers normally between 0 and GridResolution - 1 (they can be
       out of bounds a little bit), in the current cascade.  We must transform them
       to coordinates in the next bigger cascade.  This is essentially divided by two
       plus a quarter of GridResolution.  But we need to be more careful than that in
       order to do the interpolation right.  The center of the texel in the current
       cascade is at "id + float3(0.5)".  In the next bigger cascade coordinates, the
       same point is at "(id + float3(0.5)) / 2 + quarter".  It's a float3 whose
       fractional part is 0.25 or 0.75 (for each of x, y, z).  We can sample the
       bigger texture at any float3 whose fractional part is 0.5 (for each of x, y, z).
       This gives a non-trivial weighting average of 8 points.
     */
    float3 col;
    float3 texel = (id + 0.5) * 0.5 + cascade_index;
    int3 round_id = (uint3)texel;

    int3 d = int3(round_id.x > texel.x ? 1 : -1,
                  round_id.y > texel.y ? 1 : -1,
                  round_id.z > texel.z ? 1 : -1);

    col  = ApplyTransparency(LightingTower[round_id]) * (0.75 * 0.75 * 0.75);

    col += ApplyTransparency(LightingTower[round_id + int3(d.x, 0, 0)]) * (0.25 * 0.75 * 0.75);
    col += ApplyTransparency(LightingTower[round_id + int3(0, d.y, 0)]) * (0.75 * 0.25 * 0.75);
    col += ApplyTransparency(LightingTower[round_id + int3(0, 0, d.z)]) * (0.75 * 0.75 * 0.25);

    col += ApplyTransparency(LightingTower[round_id + int3(d.x, d.y, 0)]) * (0.25 * 0.25 * 0.75);
    col += ApplyTransparency(LightingTower[round_id + int3(d.x, 0, d.z)]) * (0.25 * 0.75 * 0.25);
    col += ApplyTransparency(LightingTower[round_id + int3(0, d.y, d.z)]) * (0.75 * 0.25 * 0.25);

    col += ApplyTransparency(LightingTower[round_id + d]) * (0.25 * 0.25 * 0.25);
    
    return col;
}

[numthreads(4, 4, 4)]
void PropagateFromUpperLevel(uint3 id : SV_DispatchThreadID)
{
    /* propagate light from a highest-level cascade into the next-lower-level cascade
       along the two directions DZ and -DZ */
    uint3 id2;
    float3 color, color2;

    if (any(id < DZ))
    {
        color = FetchNextLightingTowerColor(int3(id) - int3(DZ), UpperCascadeIndex.xyz);
        id2 = id + DZ * (GridResolution - 1);
        color2 = FetchNextLightingTowerColor(id2 + DZ, UpperCascadeIndex.wyz);
    }
    else
    {
        id2 = id - DZ;
        color = FetchNextLightingTowerColor(int3(id2)-int3(DZ), UpperCascadeIndex.xyz);
        color *= Input_gv[id2];
        color2 = FetchNextLightingTowerColor(id + DZ, UpperCascadeIndex.wyz);
        color2 *= Input_gv[id];
    }
    LightingTower[id + CurrentCascadeIndex.xyz] = float4(color, Input_gv[id]);
    LightingTower[id2 + CurrentCascadeIndex.wyz] = float4(color2, Input_gv[id2]);
}

[numthreads(4, 4, 4)]
void UnpackFromLightingTower(uint3 id : SV_DispatchThreadID)
{
    uint dst_index = (id.z * GridResolution + id.y) * GridResolution + id.x;
    float3 color = LightingTower[id + CurrentCascadeIndex.xyz].rgb;
    dst_index *= 3;
    RSM_gv[dst_index + 0] = color.r;
    RSM_gv[dst_index + 1] = color.g;
    RSM_gv[dst_index + 2] = color.b;
}
