#pragma kernel SetToOnes
#pragma kernel PackToTexture
#pragma kernel UnpackFromTexture
#pragma kernel DirectionalCopy
#pragma kernel PropagateFromAmbient
#pragma kernel PropagateFromUpperLevel
#pragma kernel UnpackFromLightingTower

/**********************************************************************************/


RWStructuredBuffer<float> RSM_gv;
RWTexture3D<float> LPV_gv;
Texture3D<float> Input_gv, UpperLevelInput_gv;
uint GridResolution;
uint3 DX, DY, DZ;
uint4 CascadeZIndex;
RWTexture3D<float4> LightingTowerForward, LightingTowerBackward;
float4 AmbientForward, AmbientBackward;


[numthreads(64, 1, 1)]
void SetToOnes(uint3 id : SV_DispatchThreadID)
{
    RSM_gv[id.x] = 1.0;
}

[numthreads(4, 4, 4)]
void PackToTexture(uint3 id : SV_DispatchThreadID)
{
    uint src_index = (id.z * GridResolution + id.y) * GridResolution + id.x;
    LPV_gv[id] = RSM_gv[src_index];
}

[numthreads(4, 4, 4)]
void UnpackFromTexture(uint3 id : SV_DispatchThreadID)
{
    uint dst_index = (id.z * GridResolution + id.y) * GridResolution + id.x;
    RSM_gv[dst_index] = LPV_gv[id];
}

[numthreads(4, 4, 4)]
void DirectionalCopy(uint3 id : SV_DispatchThreadID)
{
    uint3 dst_id = id + (GridResolution >> 2);
    uint3 input_id = id * 2;

    float4 transparency1 = float4(
        Input_gv[input_id],
        Input_gv[input_id + DX],
        Input_gv[input_id + DY],
        Input_gv[input_id + DX + DY]);

    input_id += DZ;
    float4 transparency2 = float4(
        Input_gv[input_id],
        Input_gv[input_id + DX],
        Input_gv[input_id + DY],
        Input_gv[input_id + DX + DY]);

    LPV_gv[dst_id] = dot(transparency1, transparency2) * 0.25;
}

[numthreads(4, 4, 4)]
void PropagateFromAmbient(uint3 id : SV_DispatchThreadID)
{
    /* propagate light from the ambient lighting into the highest-level cascade,
       along the two directions DZ and -DZ */
    if (any(id < DZ))
        return;
    uint3 id2 = id - DZ;

    float3 color = AmbientForward.rgb;
    color *= Input_gv[id2];
    LightingTowerForward[id + uint3(0, 0, CascadeZIndex.w)] = float4(color, Input_gv[id]);

    color = AmbientBackward.rgb;
    color *= Input_gv[id];
    LightingTowerBackward[id2 + uint3(0, 0, CascadeZIndex.w)] = float4(color, Input_gv[id2]);
}

float3 ApplyTransparency(float4 color)
{
    return color.rgb * color.a;
}

float3 FetchNextLightingTowerColor(uint3 id, RWTexture3D<float4> lighting_tower)
{
    /* manually interpolate.  Note that even if we could use automatic interpolation,
       it wouldn't quite work with the way we store data as RGB plus transparency,
       because RGB is not alpha-premultiplied.  That's why we need to call
       ApplyTransparency() on all source pixels, not on the final mean value.
       This is needed because in the end we are interested in the RGB value on actual
       triangles, where the alpha is typically 0.
     */
    float3 col;
    uint3 src_id = id + CascadeZIndex.xyz;

    col  = ApplyTransparency(lighting_tower[(src_id + uint3(0, 0, 0)) >> 1]);
    col += ApplyTransparency(lighting_tower[(src_id + uint3(0, 0, 1)) >> 1]);
    col += ApplyTransparency(lighting_tower[(src_id + uint3(0, 1, 0)) >> 1]);
    col += ApplyTransparency(lighting_tower[(src_id + uint3(0, 1, 1)) >> 1]);
    col += ApplyTransparency(lighting_tower[(src_id + uint3(1, 0, 0)) >> 1]);
    col += ApplyTransparency(lighting_tower[(src_id + uint3(1, 0, 1)) >> 1]);
    col += ApplyTransparency(lighting_tower[(src_id + uint3(1, 1, 0)) >> 1]);
    col += ApplyTransparency(lighting_tower[(src_id + uint3(1, 1, 1)) >> 1]);
    
    return col / 8;
}

[numthreads(4, 4, 4)]
void PropagateFromUpperLevel(uint3 id : SV_DispatchThreadID)
{
    /* propagate light from a highest-level cascade into the next-lower-level cascade
       along the two directions DZ and -DZ */
    if (any(id < DZ))
        return;
    uint3 id2 = id - DZ;

    float3 color = FetchNextLightingTowerColor(id2 - DZ, LightingTowerForward);
    color *= Input_gv[id2];
    LightingTowerForward[id + uint3(0, 0, CascadeZIndex.w)] = float4(color, Input_gv[id]);

    color = FetchNextLightingTowerColor(id + DZ, LightingTowerBackward);
    color *= Input_gv[id];
    LightingTowerBackward[id2 + uint3(0, 0, CascadeZIndex.w)] = float4(color, Input_gv[id2]);
}

[numthreads(4, 4, 4)]
void UnpackFromLightingTower(uint3 id : SV_DispatchThreadID)
{
    uint dst_index = (id.z * GridResolution + id.y) * GridResolution + id.x;
    float3 color = LightingTowerForward[id + CascadeZIndex.xyz].rgb;
    dst_index *= 3;
    RSM_gv[dst_index + 0] = color.r;
    RSM_gv[dst_index + 1] = color.g;
    RSM_gv[dst_index + 2] = color.b;
}
