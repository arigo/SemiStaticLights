#pragma kernel SetToOnes
#pragma kernel PackToTexture
#pragma kernel UnpackFromTexture
#pragma kernel DirectionalCopy
#pragma kernel PropagateFromUpperLevel
#pragma kernel UnpackFromLightingTower

/**********************************************************************************/


RWStructuredBuffer<float> RSM_gv;
RWTexture3D<float> LPV_gv;
Texture3D<float> Input_gv;
uint GridResolution;
uint3 DX, DY, DZ;
uint4 CurrentCascadeIndex, UpperCascadeIndex;
RWTexture3D<float3> LightingTower;
float4 AmbientForward, AmbientBackward;


[numthreads(64, 1, 1)]
void SetToOnes(uint3 id : SV_DispatchThreadID)
{
    RSM_gv[id.x] = 1.0;
}

[numthreads(4, 4, 4)]
void PackToTexture(uint3 id : SV_DispatchThreadID)
{
    uint src_index = (id.z * GridResolution + id.y) * GridResolution + id.x;
    LPV_gv[id] = RSM_gv[src_index];
}

[numthreads(4, 4, 4)]
void UnpackFromTexture(uint3 id : SV_DispatchThreadID)
{
    uint dst_index = (id.z * GridResolution + id.y) * GridResolution + id.x;
    RSM_gv[dst_index] = LPV_gv[id];
}

[numthreads(4, 4, 4)]
void DirectionalCopy(uint3 id : SV_DispatchThreadID)
{
    uint3 dst_id = id + (GridResolution >> 2);
    uint3 input_id = id * 2;

    float4 transparency1 = float4(
        Input_gv[input_id],
        Input_gv[input_id + DX],
        Input_gv[input_id + DY],
        Input_gv[input_id + DX + DY]);

    input_id += DZ;
    float4 transparency2 = float4(
        Input_gv[input_id],
        Input_gv[input_id + DX],
        Input_gv[input_id + DY],
        Input_gv[input_id + DX + DY]);

    LPV_gv[dst_id] = dot(transparency1, transparency2) * 0.25;
}

#if 0
[numthreads(4, 4, 4)]
void PropagateFromAmbient(uint3 id : SV_DispatchThreadID)
{
    /* propagate light from the ambient lighting into the highest-level cascade,
       along the two directions DZ and -DZ */
    uint3 id2;
    float3 color = AmbientForward.rgb;
    float3 color2 = AmbientBackward.rgb;

    if (any(id < DZ))
    {
        id2 = id + DZ * (GridResolution - 1);
    }
    else
    {
        id2 = id - DZ;
        color *= Input_gv[id2];
        color2 *= Input_gv[id];
    }
    LightingTower[id + CurrentCascadeIndex.xyz] = float4(color, Input_gv[id]);
    LightingTower[id2 + CurrentCascadeIndex.wyz] = float4(color2, Input_gv[id2]);
}

float3 ApplyTransparency(float4 color)
{
    return color.rgb * color.a;
}

float3 FetchNextLightingTowerColor(int3 id, uint3 cascade_index)
{
    /* manually interpolate.  Note that even if we could use automatic interpolation,
       it wouldn't quite work with the way we store data as RGB plus transparency,
       because RGB is not alpha-premultiplied.  That's why we need to call
       ApplyTransparency() on all source pixels, not on the final mean value.
       This is needed because in the end we are interested in the RGB value on actual
       triangles, where the alpha is typically 0.

       'id' is three integers normally between 0 and GridResolution - 1 (they can be
       out of bounds a little bit), in the current cascade.  We must transform them
       to coordinates in the next bigger cascade.  This is essentially divided by two
       plus a quarter of GridResolution.  But we need to be more careful than that in
       order to do the interpolation right.  The center of the texel in the current
       cascade is at "id + float3(0.5)".  In the next bigger cascade coordinates, the
       same point is at "(id + float3(0.5)) / 2 + quarter".  It's a float3 whose
       fractional part is 0.25 or 0.75 (for each of x, y, z).  We can sample the
       bigger texture at any float3 whose fractional part is 0.5 (for each of x, y, z).
       This gives a non-trivial weighting average of 8 points.
     */
    float3 col;
    float3 texel = (id + 0.5) * 0.5 + cascade_index;
    int3 round_id = (uint3)texel;

    int3 d = int3(round_id.x > texel.x ? 1 : -1,
                  round_id.y > texel.y ? 1 : -1,
                  round_id.z > texel.z ? 1 : -1);

    col  = ApplyTransparency(LightingTower[round_id]) * (0.75 * 0.75 * 0.75);

    col += ApplyTransparency(LightingTower[round_id + int3(d.x, 0, 0)]) * (0.25 * 0.75 * 0.75);
    col += ApplyTransparency(LightingTower[round_id + int3(0, d.y, 0)]) * (0.75 * 0.25 * 0.75);
    col += ApplyTransparency(LightingTower[round_id + int3(0, 0, d.z)]) * (0.75 * 0.75 * 0.25);

    col += ApplyTransparency(LightingTower[round_id + int3(d.x, d.y, 0)]) * (0.25 * 0.25 * 0.75);
    col += ApplyTransparency(LightingTower[round_id + int3(d.x, 0, d.z)]) * (0.25 * 0.75 * 0.25);
    col += ApplyTransparency(LightingTower[round_id + int3(0, d.y, d.z)]) * (0.75 * 0.25 * 0.25);

    col += ApplyTransparency(LightingTower[round_id + d]) * (0.25 * 0.25 * 0.25);
    
    return col;
}
#endif

float3 FetchBiggerLightCell(int3 id, uint3 cascade_index)
{
    if (cascade_index.y == 0)
    {
        /* last-level cascade */
        return AmbientForward.rgb;
    }



    /* dot(id, DZ) is an odd integer here (possibly equal to -1).
       'texel' is a float3 where the DZ component has got a fraction 0.25, and the other two are
       each either 0.25 or 0.75.
    */
    float3 texel = (id - 0.5) * 0.5 + cascade_index;
    uint3 round_id = (uint3)texel;

    float3 col00 = LightingTower[round_id];
    float3 col01 = LightingTower[round_id + DX];
    float3 col10 = LightingTower[round_id + DY];
    float3 col11 = LightingTower[round_id + DX + DY];

    /*if (CurrentCascadeIndex.z == 16 * 6 && id.x == 8 && id.y == 5 && id.z == 4 &&
        //(round_id + DX + DY ).x == 8 &&
        //(round_id + DX + DY ).y == 7 &&
        //(round_id + DX + DY ).z == 7 + 7*16 &&
        1)
    {
        //return float3(1, 0, 0);
    }*/

    /* If lastbit_dx == 0, we keep col00&col10 with a factor 0.75, and col01&col11 with a
       factor 0.25.  If lastbit_dx == 1, it's the opposite. */
    float f = dot(texel - round_id, DX);
    col00 *= 1 - f;
    col01 *= f;
    col10 *= 1 - f;
    col11 *= f;

    /* Same with lastbit_dy */
    f = dot(texel - round_id, DY);
    col00 *= 1 - f;
    col01 *= 1 - f;
    col10 *= f;
    col11 *= f;

    return col00 + col01 + col10 + col11;
}

[numthreads(4, 4, 4)]
void PropagateFromUpperLevel(uint3 id : SV_DispatchThreadID)
{
    /* propagate light from a highest-level cascade into the next-lower-level cascade
       along the two directions DZ and -DZ */
    /*uint3 id2;
    float3 color, color2;*/



        /*        -->>> DZ = direction of light propagation -->>>

              +-----+-----+-----+-----+
              |     |     |     |     |
              | id4 | id3 | id2 | id  |    LT[id].rgb :=
              | ----+-----+-----+-----+       LT[idbig].rgb * LT[id4].a * LT[id3].a * LT[id2].a;
              |            
              | idbig     |
              +-----------+

                    +-----+-----+-----+
                    |     |     |     |
                    | id3 | id2 | id  |    LT[id].rgb :=
                    | ----+-----+-----+       LT[idbig].rgb * LT[id3].a * LT[id2.a];
                    |
                    | idbig     |
                    +-----------+

              LightingTower[id] contains the color of light incoming into the cube
              at id through its incoming face.

              Input_gv[id] is the mean opacity inside the cube (a=0: fully opaque)

         Special cases if 'id' is near the edge:

              +-----+-----+
              |     |     |
              | id2 | id  |      if idz == 1
              | ----+-----+
              |
              | idbig     |
              +-----------+

                    +-----+
                    |     |
                    | id  |          if idz == 0
                    | ----+ ----+
                    |           |
                    | idbig     |
                    +-----------+
         */


    uint idz = dot(id, DZ);
    float alpha;
    float3 bigger;

    if (idz < 2)
    {
        if (idz == 1)
        {
            alpha = Input_gv[id - DZ];
            bigger = FetchBiggerLightCell(id, UpperCascadeIndex.xyz);
        }
        else
        {
            alpha = 1;
            bigger = FetchBiggerLightCell(id + DZ, UpperCascadeIndex.xyz);
        }
    }
    else
    {
        uint3 id2 = id - DZ;
        uint3 id3 = id2 - DZ;
        alpha = Input_gv[id3] * Input_gv[id2];


        if (idz & 1)    /* first case above */
        {
            uint3 id4 = id3 - DZ;
            alpha *= Input_gv[id4];
            bigger = FetchBiggerLightCell(id3, UpperCascadeIndex.xyz);
        }
        else    /* second case above */
        {
            bigger = FetchBiggerLightCell(id2, UpperCascadeIndex.xyz);
        }
    }
    /*if ((id + CurrentCascadeIndex.xyz).x == 8 &&
        (id + CurrentCascadeIndex.xyz).y == 7 &&
        (id + CurrentCascadeIndex.xyz).z == 7 + 7 * 16 &&
        1)
    {
        bigger = float3(1, 0, 0);
        alpha = 1;
    }*/
    LightingTower[id + CurrentCascadeIndex.xyz] = bigger * alpha;

    //LightingTower[id2 + CurrentCascadeIndex.wyz] = float4(color2, Input_gv[id2]);
}

[numthreads(4, 4, 4)]
void UnpackFromLightingTower(uint3 id : SV_DispatchThreadID)
{
    uint dst_index = (id.z * GridResolution + id.y) * GridResolution + id.x;
    float3 color = LightingTower[id + CurrentCascadeIndex.xyz];
    dst_index *= 3;
    RSM_gv[dst_index + 0] = color.r;
    RSM_gv[dst_index + 1] = color.g;
    RSM_gv[dst_index + 2] = color.b;
}
